using CSharpWasm;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Classification;
using Microsoft.CodeAnalysis.Completion;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Host.Mef;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Extensions.Options;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

namespace CSharpWasm.Services;

internal class CSharpProvider : ICSharpProvider, IDisposable
{
    private readonly CSharpProviderOptions _options;
    private readonly HttpClient _client;

    private MetadataReference[] _metadataReferences = [];
    private bool _isInitialized = false;

    private readonly List<IDisposable> _disposables = [];
    private readonly SyntaxTree _globalUsingSyntaxTree;
    private readonly CSharpGeneratorDriver _generatorDriver;

    private readonly AdhocWorkspace _workspace;
    private Project _project;

    /// <summary>
    /// 
    /// </summary>
    /// <param name="options"></param>
    /// <param name="httpClient"></param>
    /// <exception cref="ArgumentException"></exception>
    public CSharpProvider(IOptions<CSharpProviderOptions> options, HttpClient httpClient)
    {
        if (!OperatingSystem.IsBrowser())
            throw new NotSupportedException("This dynamic compilation is going to be for web only! Running dynamically compiled code locally is a security risk!");

        _options = options.Value;
        _client = httpClient;

        if (options.Value.CSharpCompilationOptions.ConcurrentBuild)
            throw new ArgumentException("ConcurrentBuild is not supported in Blazor WebAssembly. Set it to false.", nameof(options));

        StringBuilder globalUsingsFile = new();
        globalUsingsFile.AppendLine("// <auto-generated/>");
        foreach (var @using in options.Value.CSharpCompilationOptions.Usings)
        {
            globalUsingsFile.AppendLine("global using ").Append(@using).AppendLine(";");
        }

        string globalUsingsSource = globalUsingsFile.ToString();
        _globalUsingSyntaxTree = CSharpSyntaxTree.ParseText(globalUsingsSource, options.Value.CSharpParseOptions);

        MefHostServices host = MefHostServices.Create(MefHostServices.DefaultAssemblies);

        _workspace = new AdhocWorkspace(host);
        _project = _workspace.AddProject("DynamicCompile", LanguageNames.CSharp)
            .WithCompilationOptions(_options.CSharpCompilationOptions)
            .WithParseOptions(_options.CSharpParseOptions);

        _project = _project.AddDocument("GlobalUsings.g.cs", globalUsingsSource).Project;

        IIncrementalGenerator[] generatorArray = options
            .Value
            .SourceGenerators
            .Select(Activator.CreateInstance)
            .Cast<IIncrementalGenerator>()
            .ToArray();

        _generatorDriver = CSharpGeneratorDriver.Create(generatorArray);
    }

    public async Task<IEnumerable<(string Text, string SyntaxHints)>> SyntaxHighlight(string source)
    {
        await InitalizeLibrariesAsync();

        // TODO: source gen
        Document document = _project.AddDocument("Program.cs", source);
        SourceText sourceText = await document.GetTextAsync();

        IEnumerable<ClassifiedSpan> classifiedSpans = await Classifier.GetClassifiedSpansAsync(document, new TextSpan(0, sourceText.Length), CancellationToken.None);
        var highlighting = FillGaps(sourceText, classifiedSpans);

        return highlighting;
    }

    public async Task<IEnumerable<(string CompleitionText, CSharpCodeCompletionTags Tags)>> GetCompletions(string source, int position)
    {
        Document document = _project.AddDocument("Program.cs", source);

        // TODO: source gen

        CompletionService? completionService = CompletionService.GetService(document);
        if (completionService is null)
            return [];
        
        CompletionList results = await completionService.GetCompletionsAsync(document, position);
        
        return results
            .ItemsList
            .Select(comp =>
            {
                CSharpCodeCompletionTags tag = default;

                foreach (var tagString in comp.Tags)
                    tag |= CSharpCodeCompletionUtils.GetTagFromString(tagString);

                return (comp.DisplayText, tag);
            });
    }

    private static IEnumerable<(string Text, string UsedClass)> FillGaps(SourceText sourceText, IEnumerable<ClassifiedSpan> ranges)
    {
        int lastSegmentEnd = 0;
        int index = 0;
        foreach (var span in ranges)
        {
            if (ClassificationTypeNames.AdditiveTypeNames.Contains(span.ClassificationType))
                continue;

            TextSpan textSpan = span.TextSpan;
            string text = sourceText.ToString(span.TextSpan);
            string usedClass = @span.ClassificationType.Replace(' ', '-');

            if (span.TextSpan.Start != lastSegmentEnd)
            {
                if (textSpan.Start - lastSegmentEnd < 0)
                    continue;

                yield return GetSubTextWhiteSpace(lastSegmentEnd, textSpan.Start);

                (string, string) GetSubTextWhiteSpace(int start, int end) => (sourceText.GetSubText(new TextSpan(start, end - start)).ToString(), ClassificationTypeNames.WhiteSpace);
            }

            index++;
            lastSegmentEnd = textSpan.End;
            yield return (text, usedClass);
        }
    }

    public async Task<CSharpCompilationResult> Compile(string source, bool isExecuatble)
    {
        await InitalizeLibrariesAsync();

        CreateCompilation(isExecuatble, source, out CSharpCompilation compilation, out SyntaxTree syntaxTree);

        var generatorDriver = _generatorDriver
            .RunGeneratorsAndUpdateCompilation(compilation, out Compilation newCompilation, out ImmutableArray<Diagnostic> diags);

        compilation = (CSharpCompilation)newCompilation;

        using MemoryStream memoryStream = new();
        EmitResult emitResult = compilation.Emit(memoryStream);
        
        var bytes = memoryStream.ToArray();
        Assembly? assembly = emitResult.Success ? Assembly.Load(bytes) : null;

        return new CSharpCompilationResult(
            assembly,
            emitResult.Success,
            emitResult.Diagnostics
            );
    }
    
    private void CreateCompilation(bool isExecutable, string source, out CSharpCompilation compilation, out SyntaxTree syntaxTree)
    {
        syntaxTree = CSharpSyntaxTree.ParseText(source, _options.CSharpParseOptions);

        //https://github.com/dotnet/roslyn/issues/58119
        //global usings need to be manually added
        var compOptions = _options.CSharpCompilationOptions;

        if (!isExecutable)
            compOptions = compOptions.WithOutputKind(OutputKind.DynamicallyLinkedLibrary);

        compilation = CSharpCompilation.Create(
            assemblyName: "dynamic.dll",
            syntaxTrees: [syntaxTree, _globalUsingSyntaxTree],
            options: compOptions,
            references: _metadataReferences);
    }

    private async ValueTask InitalizeLibrariesAsync()
    {
        if (_isInitialized)
            return;

        List<MetadataReference> refs = [];

        foreach (var name in _options.Libraries)
        {
            Stream stream = await _client.GetStreamAsync(name);
            _disposables.Add(stream);
            refs.Add(MetadataReference.CreateFromStream(stream));
        }

        _project = _project.AddMetadataReferences(refs);
        _metadataReferences = refs.ToArray();
        _isInitialized = true;
    }

    internal static async ValueTask<SemanticModel> GetRequiredSemanticModelAsync(Document document, CancellationToken cancellationToken)
    {
        if (document.TryGetSemanticModel(out var semanticModel))
            return semanticModel;

        semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);
        return semanticModel ?? throw new InvalidOperationException();
    }

    public void Dispose()
    {
        foreach (var disposable in _disposables)
            disposable.Dispose();
    }
}